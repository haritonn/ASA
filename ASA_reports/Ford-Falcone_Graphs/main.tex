\documentclass[otchet, times]{SCWorks}
% Тип обучения (одно из значений):
%    bachelor   - бакалавриат (по умолчанию)
%    spec       - специальность
%    master     - магистратура
% Форма обучения (одно из значений):
%    och        - очное (по умолчанию)
%    zaoch      - заочное
% Тип работы (одно из значений):
%    coursework - курсовая работа (по умолчанию)
%    referat    - реферат
%  * otchet     - универсальный отчет
%  * nirjournal - журнал НИР
%  * digital    - итоговая работа для цифровой кафдры
%    diploma    - дипломная работа
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% Включение шрифта
%    times      - включение шрифта Times New Roman (если установлен)
%                 по умолчанию выключен
\usepackage{preamble}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Алгоритм Форда"=Фалкерсона}

% Курс
\course{2}

% Группа
\group{211}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
% \department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
% \napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
% \napravlenie{09.03.01 "--- Информатика и вычислительная техника}
%\napravlenie{09.03.04 "--- Программная инженерия}
% \napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
% \studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Пицика Харитона Николаевича}

% Заведующий кафедрой 

% Руководитель ДПП ПП для цифровой кафедры (перекрывает заведующего кафедры)
% \chpretitle{
%     заведующий кафедрой математических основ информатики и олимпиадного\\
%     программирования на базе МАОУ <<Ф"=Т лицей №1>>
% }
% \chtitle{г. Саратов, к.\,ф.-м.\,н., доцент}
% \chname{Кондратова\, Ю.\,Н.}

% Научный руководитель (для реферата преподаватель проверяющий работу)


% Руководитель практики от организации (руководитель для цифровой кафедры)


% Руководитель НИР
%\nirtitle{доцент, к.\,п.\,н.} % степень, звание
%\nirname{В.\,А.\,Векслер}

% Семестр (только для практики, для остальных типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных типов работ не
% используется)
%\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики, для
% остальных типов работ не используется)
%\duration{2}

% Даты начала и окончания практики (только для практики, для остальных типов
% работ не используется)
%\practStart{01.07.2022}
%\practFinish{13.01.2023}

% Год выполнения отчета
\date{2025}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам (по умолчанию -
% нумерация сквозная) (допускается оба вида нумерации)
\secNumbering
\tableofcontents

\newpage
\section{Постановка проблематики, терминология}
В теории графов, транспортная сеть (или же flow network) представляет собой ориентированный граф $G(V, E)$, в котором каждое ребро имеет так называемую пропускную способность, которая задаётся функцией 
$c:V \times V\rightarrow \mathbb{R}_+ $, причем для любого $e \notin E$ значение функции равно 0. Потоком называется функция $f:V \times V \rightarrow \mathbb{R}_+$

Одна из самых распространённых задач в графах "--- задача о максимальном потоке. В теории оптимизации и в теории графов, задача о максимальном потоке заключается в нахождении такого потока в транспортной сети, что сумма потоков из истока максимальная. В 1955 году Лестер Форд и Делберт Фалкерсон впервые построили алгоритм, специально предназначенный для этой задачи. Их алгоритм получил название алгоритм Форда"=Фалкерсона.

\section{Идея алгоритма}
Идея алгоритма заключается в следующем. Изначально величине потока присваивается 0: $f(u,v) = 0 ~\forall (u,v) \in V$. Затем величина потока итеративно увеличивается посредством поиска увеличивающегося пути. Рассмотрим алгоритм пошагово:
\begin{itemize}
    \item     В начальный момент времени поток, который мы хотим провести через нашу сеть, должен быть равен нулю. Остаточная сеть совпадает с исходной сетью;
    \item     Находим любой путь из истока в сток в остаточной сети. Если путь не находим, утверждается, что поток является максимальным;
    \item     Пускаем через найденный путь поток равный минимальному весу ребра, которое входит в множество рёбер найденного пути;
    \item     Из веса рёбер на этом пути высчитываем размер потока, который мы пустили;
    \item     А к весу обратных рёбер (будем считать, что они существуют в остаточной сети и равны 0) прибавляем размер потока. Другими словами, на предыдущем шаге мы отправили некоторое количество потока из текущей вершины в следующую, а теперь при желании можем вернуть это же количество потока обратно в текущую;
    \item    Возвращаемся обратно к нахождению пути в остаточной сети после модификации.
\end{itemize}

Алгоритм Форда"=Фалкерсона реализован, используя обход в глубину (DFS).
\section{Реализация, код программы}
\begin{minted}[fontsize=\small, breaklines]{cpp}
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int INF = 1e9; // большое число, для обозначения бесконечности

// Структура графа
struct Graph {
    int n; // число вершин
    vector<vector<int>> capacity; // матрица пропускных способностей
    vector<vector<int>> adj; // список смежности

    Graph(int n) : n(n) {
        capacity.assign(n, vector<int>(n, 0));
        adj.resize(n);
    }

    // Добавление ребра
    void addEdge(int u, int v, int cap) {
        capacity[u][v] = cap;
        adj[u].push_back(v);
        adj[v].push_back(u); // добавляем обратную связь для поиска путей
    }
};

// Функция поиска пути увеличения с помощью DFS
int dfs(int u, int t, vector<bool>& visited, vector<int>& parent, const vector<vector<int>>& capacity, const vector<vector<int>>& adj) {
    visited[u] = true;
    if (u == t) return INF; // достигли стока, возвращаем бесконечность (максимальное возможное увеличение)
    
    for (int v : adj[u]) {
        if (!visited[v] && capacity[u][v] > 0) {
            parent[v] = u; // запоминаем предка для восстановления пути
            int flow = dfs(v, t, visited, parent, capacity, adj);
            if (flow > 0) {
                return min(flow, capacity[u][v]); // минимальная пропускная способность по пути
            }
        }
    }
    return 0; // путь не найден
}

// Основная функция для поиска максимального потока
int fordFulkerson(Graph& g, int s, int t) {
    int maxFlow = 0;
    vector<vector<int>> capacity = g.capacity; // копируем матрицу пропускных способностей

    while (true) {
        vector<bool> visited(g.n, false);
        vector<int> parent(g.n, -1);

        // ищем путь увеличения с помощью DFS
        int flow = dfs(s, t, visited, parent, capacity, g.adj);
        if (flow == 0) break; // больше путей нет — алгоритм завершен

        maxFlow += flow;

        // обновляем остаточные пропускные способности по найденному пути
        int v = t;
        while (v != s) {
            int u = parent[v];
            capacity[u][v] -= flow;   // уменьшаем пропускную способность по прямому рёбру
            capacity[v][u] += flow;   // увеличиваем по обратному рёбру (обратный поток)
            v = u;
        }
    }

    return maxFlow;
}
\end{minted}

\section{Анализ сложности}
В случае, если значения пропускных способностей являются иррациональными числами, алгоритм может зациклиться в бесконечность. В случае с целыми числами, сложность алгоритма составляет $O(|E|f)$, где $E$ "--- множество рёбер, $f$ "--- максимальный поток в графе. Это обусловлено тем, что каждый увеличивающий путь можно найти за $O(E)$ и увеличивает поток как минимум на единицу. В худшем случае алгоритм будет работать $O(|V+E|f)$

\section{Достоинства и недостатки алгоритма, особенности использования}
К плюсам данного алгоритма можно отнести:
\begin{itemize}
    \item Теоретически доказанное гарантированное нахождение максимального пути;
    \item Распространённость. Алгоритм можно применять везде, где в сетевом потоке необходимо найти максимальный путь, но при условии, что пропускные способности неотрицательные;
    \item Гибкость. Можно изменить алгоритм поиска пути увеличения. Например, заменить обход в глубину на обход в ширину, что даёт другую сложность $O(VE^2)$
\end{itemize}

Как уже описывалось выше, одним из главных недостатков данного алгоритма является невозможность работы с вещественными иррациональными числами, поскольку существует вероятность, что в таком случае алгоритм не сможет завершить свою работу. Также к минусам можно отнести сложность алгоритма в худшем случае, так как в худшем случае происходит слишком много итераций. Обычно, для оптимизации вычислений, вместо обхода в глубину используют обход в ширину, что является реализацией другого алгоритма, Эдмонса"=Карпа.



% Раздел "Обозначения и сокращения". Может отсутствовать в работе
% \abbreviations
% \begin{description}
%     \item ... "--- ...
%     \item ... "--- ...
% \end{description}

% Раздел "Определения". Может отсутствовать в работе
% \definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и
% "Определения"
% \defabbr


% После введения — серии \section, \subsection и т.д.

% Библиографический список, составленный вручную, без использования BibTeX
%
% \begin{thebibliography}{99}
%   \bibitem{Ione} Источник 1.
%   \bibitem{Itwo} Источник 2
% \end{thebibliography}

% Отобразить все источники. Даже те, на которые нет ссылок.
% \nocite{*}

% Меняем inputencoding на лету, чтобы работать с библиографией в кодировке
% `cp1251', в то время как остальной документ находится в кодировке `utf8'
% Credit: Никита Рыданов

% При использовании biblatex вместо bibtex
% \printbibliography

% Окончание основного документа и начало приложений Каждая последующая секция
% документа будет являться приложением

\end{document}